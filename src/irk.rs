//function that converts a string to lowercase
fn to_lower(s: &str) -> String {
    s.chars().map(|c| c.to_ascii_lowercase()).collect()
}

//loads the Butcher tableaus for the given family and stage count
pub fn get_tableau(family: &str, s: usize) -> Result<(Vec<Vec<f64>>, Vec<f64>, Vec<f64>), String> {
    let family_lower = to_lower(family);
    
    if family_lower.starts_with("gauss") {
        match s {
            1 => {
                Ok((vec![vec![0.5]], vec![1.0], vec![0.5]))
            }
            2 => {
                Ok((vec![
                    vec![0.25, 0.5386751345948129],
                    vec![-0.03867513459481288, 0.25],
                ], vec![0.5, 0.5], vec![0.7886751345948129, 0.21132486540518712]))
            }
            3 => {
                Ok((vec![
                    vec![0.1388888888888889, 0.48042111196938335, 0.26798833376246945],
                    vec![-0.022485417203086815, 0.2222222222222222, 0.3002631949808646],
                    vec![0.009789444015308326, -0.03597666752493890, 0.1388888888888889],
                ], vec![0.2777777777777778, 0.4444444444444444, 0.2777777777777778],
                vec![0.8872983346207417, 0.5, 0.1127016653792583]))
            }
            4 => {
                Ok((vec![
                    vec![0.08696371128436346, 0.35267675751627186, 0.31344511474186835, 0.1774825722545226],
                    vec![-0.014190694931141143, 0.16303628871563654, 0.3539530060337440, 0.16719192197418877],
                    vec![0.006735500594538155, -0.027880428602470895, 0.16303628871563654, 0.18811811749986807],
                    vec![-0.003555149685795683, 0.012627462689404725, -0.026604180084998793, 0.08696371128436346],
                ], vec![0.17392742256872693, 0.32607257743127307, 0.32607257743127307, 0.17392742256872693],
                vec![0.9305681557970263, 0.6699905217924281, 0.33000947820757187, 0.06943184420297371]))
            }
            5 => {
                Ok((vec![
                    vec![0.05923172126404727, 0.25888469960875927, 0.2731900436258015, 0.24490812891049542, 0.11687532956022855],
                    vec![-0.00968756314195074, 0.11965716762484162, 0.30903655906408665, 0.22899605457899988, 0.12123243692686415],
                    vec![0.004687154523869941, -0.020690316430958285, 0.14222222222222222, 0.2600046516806415, 0.11377628800422460],
                    vec![-0.002768994398769603, 0.010318280670683357, -0.024592114619642200, 0.11965716762484162, 0.12815100567004528],
                    vec![0.001588112967865998, -0.005593793660812185, 0.011254400818642956, -0.019570364359076037, 0.05923172126404727],
                ], vec![0.11846344252809454, 0.23931433524968323, 0.28444444444444444, 0.23931433524968323, 0.11846344252809454],
                vec![0.9530899229693320, 0.7692346550528416, 0.5, 0.23076534494715845, 0.04691007703066800]))
            }
            _ => Err("Gauss-Legendre only implemented for s = 1...5".to_string()),
        }
    }
    else if family_lower.starts_with("radau") {
        match s {
            2 => {
                Ok((vec![
                    vec![0.41666666666666667, -0.08333333333333333],
                    vec![0.75, 0.25],
                ], vec![0.75, 0.25], vec![0.3333333333333333, 1.0]))
            }
            3 => {
                Ok((vec![
                    vec![0.19681547722366043, -0.06553542585019839, 0.023770974348220152],
                    vec![0.39442431473908727, 0.29207341166522846, -0.04154875212599793],
                    vec![0.37640306270046727, 0.5124858261884216, 0.11111111111111111],
                ], vec![0.37640306270046727, 0.5124858261884216, 0.11111111111111111],
                vec![0.15505102572168219, 0.6449489742783178, 1.0]))
            }
            4 => {
                Ok((vec![
                    vec![0.20689257393535890, 0.23438399574740026, -0.04785712804854072, 0.01604742280651627],
                    vec![-0.04030922072352221, 0.11299947932315619, 0.02580237742033639, -0.009904676507266424],
                    vec![0.4061232638673733, 0.21668178462325034, 0.18903651817005634, -0.02418210489983294],
                    vec![0.38819346884317188, 0.22046221117676838, 0.32884431998005974, 0.06250000000000000],
                ], vec![0.38819346884317188, 0.22046221117676838, 0.32884431998005974, 0.0625],
                vec![0.4094668644407347, 0.08858795951270395, 0.7876594617608471, 1.0]))
            }
            5 => {
                Ok((vec![
                    vec![0.14621486784749350, 0.15377523147918247, -0.03644456890512809, 0.02123306311930472, -0.007935579902728778],
                    vec![-0.02673533110794557, 0.07299886431790332, 0.01867692976398435, -0.01287910609330644, 0.005042839233882015],
                    vec![0.29896712949128348, 0.14006304568480987, 0.16758507013524896, -0.03396910168661775, 0.010944288744192252],
                    vec![0.27650006876015923, 0.14489430810953476, 0.32579792291042103, 0.12875675325490976, -0.015708917378805328],
                    vec![0.28135601514946206, 0.14371356079122594, 0.31182652297574125, 0.22310390108357074, 0.04000000000000000],
                ], vec![0.28135601514946206, 0.14371356079122594, 0.31182652297574125, 0.22310390108357074, 0.04],
                vec![0.27684301363812383, 0.05710419611451768, 0.5835904323689168, 0.8602401356562194, 1.0]))
            }
            _ => Err("Radau IIA only implemented for s = 2...5".to_string()),
        }
    }
    else if family_lower.starts_with("lobatto") {
        match s {
            2 => {
                Ok((vec![
                    vec![0.0, 0.0],
                    vec![0.5, 0.5],
                ], vec![0.5, 0.5], vec![0.0, 1.0]))
            }
            3 => {
                Ok((vec![
                    vec![0.0, 0.0, 0.0],
                    vec![0.20833333333333333, 0.3333333333333333, -0.041666666666666664],
                    vec![0.16666666666666667, 0.6666666666666666, 0.16666666666666666],
                ], vec![0.16666666666666666, 0.6666666666666666, 0.16666666666666666],
                vec![0.0, 0.5, 1.0]))
            }
            4 => {
                Ok((vec![
                    vec![0.0, 0.0, 0.0, 0.0],
                    vec![0.07303276685416842, 0.22696723314583158, 0.45057403089581055, -0.02696723314583158],
                    vec![0.11030056647916491, -0.03390736422914388, 0.18969943352083508, 0.01030056647916491],
                    vec![0.08333333333333333, 0.4166666666666667, 0.4166666666666667, 0.08333333333333333],
                ], vec![0.08333333333333333, 0.4166666666666667, 0.4166666666666667, 0.08333333333333333],
                vec![0.0, 0.7236067977499790, 0.2763932022500210, 1.0]))
            }
            5 => {
                Ok((vec![
                    vec![0.0, 0.0, 0.0, 0.0, 0.0],
                    vec![0.05370013924241453, 0.15247745287881054, 0.37729127742211367, 0.26158639799680673, -0.017728432186156897],
                    vec![0.040625, -0.030961961100820556, 0.17777777777777778, 0.30318418332304278, 0.009375],
                    vec![0.06772843218615690, 0.01063582422541549, -0.021735721866558114, 0.11974476934341168, -0.003700139242414531],
                    vec![0.05, 0.2722222222222222, 0.35555555555555557, 0.2722222222222222, 0.05],
                ], vec![0.05, 0.2722222222222222, 0.35555555555555557, 0.2722222222222222, 0.05],
                vec![0.0, 0.8273268353539886, 0.5, 0.1726731646460114, 1.0]))
            }
            _ => Err("Lobatto IIIC only implemented for s = 2...5".to_string()),
        }
    }
    else {
        Err(format!("Unknown IRK family '{}'. Must be 'gauss', 'radau', or 'lobatto'.", family))
    }
}

//defines the IRK step with Gauss-Seidel relaxation
pub fn step_collocation<F>(f: F, t: f64, y: &[f64], h: f64,
                           a: &[Vec<f64>], b: &[f64], c: &[f64],
                           s: usize, n: usize, y_next: &mut [f64],
                           sweeps: usize, tol: f64)
where
    F: Fn(f64, &[f64], &mut [f64]),
{
    //initializes all stages with the initial guess y
    let mut y_stages: Vec<Vec<f64>> = (0..s).map(|_| y.to_vec()).collect();
    let mut y_old: Vec<Vec<f64>> = vec![vec![0.0; n]; s];
    let mut rhs = vec![0.0; n];
    let mut fval = vec![0.0; n];
    
    //implements Gauss-Seidel relaxation
    for _k in 0..sweeps {
        for i in 0..s {
            y_old[i] = y_stages[i].clone();
        }
        for i in 0..s {
            rhs.fill(0.0);
            for j in 0..s {
                f(t + c[j] * h, &y_stages[j], &mut fval);
                for idx in 0..n {
                    rhs[idx] += a[i][j] * fval[idx];
                }
            }
            for idx in 0..n {
                y_stages[i][idx] = y[idx] + h * rhs[idx];
            }
        }
        
        //computes L2 norm of all stage differences
        let mut diff_norm = 0.0;
        for i in 0..s {
            for idx in 0..n {
                let diff = y_stages[i][idx] - y_old[i][idx];
                diff_norm += diff * diff;
            }
        }
        diff_norm = diff_norm.sqrt();
        if diff_norm < tol {
            break;
        }
    }
    
    //computes the final state update
    y_next.copy_from_slice(y);
    for i in 0..s {
        f(t + c[i] * h, &y_stages[i], &mut fval);
        for idx in 0..n {
            y_next[idx] += h * b[i] * fval[idx];
        }
    }
}

//main solver for any collocation IRK method using Gauss-Seidel relaxation
pub fn solve_collocation<F>(f: F, t0: f64, tf: f64, y0: &[f64],
                            h: f64, n: usize, yout: &mut [Vec<f64>],
                            tgrid: &mut [f64], family: &str, s: usize,
                            sweeps: usize, tol: f64) -> Result<(), String>
where
    F: Fn(f64, &[f64], &mut [f64]),
{
    let (a, b, c) = get_tableau(family, s)?;
    
    let nsteps = ((tf - t0) / h).ceil() as usize;
    
    for k in 0..=nsteps {
        tgrid[k] = t0 + k as f64 * h;
    }
    
    yout[0] = y0.to_vec();
    let mut y = y0.to_vec();
    
    for k in 0..nsteps {
        step_collocation(&f, tgrid[k], &y, h, &a, &b, &c, s, n, &mut yout[k+1], sweeps, tol);
        y = yout[k+1].clone();
    }
    
    Ok(())
}